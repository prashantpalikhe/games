<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Match-Up: Mastery</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet" />
    <style>
      :root {
        --primary: #58cc02;
        --primary-dark: #46a302;
        --secondary: #1cb0f6;
        --secondary-dark: #1899d6;
        --wrong: #ff4b4b;
        --bg: #131f24;
        --card-bg: #ffffff;
        --text: #4b4b4b;
        --border: #e5e5e5;
      }

      body {
        font-family: "Nunito", sans-serif;
        background-color: var(--bg);
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        margin: 0;
        padding: 10px;
        overflow: hidden;
      }

      /* --- Header & Controls --- */
      header {
        width: 100%;
        max-width: 600px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 10px 5px;
      }

      .controls-row {
        display: flex;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      select {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #37464f;
        background: #131f24;
        color: #afafaf;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
      }

      select:hover {
        border-color: #52656d;
        color: white;
      }

      .reset-btn {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #5c3a3a;
        background: #131f24;
        color: #c47070;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
        transition: all 0.2s;
      }

      .reset-btn:hover {
        border-color: var(--wrong);
        color: var(--wrong);
        background: rgba(255, 75, 75, 0.1);
      }

      .sheet-btn {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #37464f;
        background: #131f24;
        color: #afafaf;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
        transition: all 0.2s;
      }

      .sheet-btn:hover {
        border-color: var(--secondary);
        color: var(--secondary);
        background: rgba(28, 176, 246, 0.1);
      }

      /* Toggle Switch */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 28px;
        flex-shrink: 0;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .toggle-slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background: #37464f;
        border-radius: 28px;
        transition: 0.3s;
      }

      .toggle-slider::before {
        position: absolute;
        content: "";
        height: 22px;
        width: 22px;
        left: 3px;
        bottom: 3px;
        background: white;
        border-radius: 50%;
        transition: 0.3s;
      }

      .toggle-switch input:checked + .toggle-slider {
        background: var(--primary);
      }

      .toggle-switch input:checked + .toggle-slider::before {
        transform: translateX(24px);
      }

      #category-select {
        border-color: var(--secondary-dark);
        color: var(--secondary);
        min-width: 160px;
      }

      /* --- Progress Section --- */
      .stats-bar {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        font-size: 0.9rem;
        color: #b0bec5;
        margin-bottom: 4px;
      }

      .stats-left strong {
        color: var(--primary);
      }

      #progress-container {
        width: 100%;
        max-width: 500px;
        height: 14px;
        background: #37464f;
        border-radius: 99px;
        margin: 0 auto 15px auto;
        overflow: hidden;
        border: 2px solid #263238;
      }

      #progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--primary), #82e827);
        transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: 0 0 10px rgba(88, 204, 2, 0.4);
      }

      /* --- Game Board --- */
      #game-board {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        width: 100%;
        max-width: 500px;
        height: 100%;
        align-content: start;
        padding-bottom: 20px;
      }

      .column {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .card-slot {
        height: 60px;
        position: relative;
      }

      .card {
        position: absolute;
        inset: 0;
        background-color: var(--card-bg);
        border: 2px solid var(--border);
        border-bottom: 5px solid var(--border);
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 800;
        color: var(--text);
        user-select: none;
        touch-action: manipulation;
        transition: transform 0.1s, border-bottom 0.1s;
        padding: 0 34px 0 12px; /* Space for speaker icon */
        z-index: 10;
      }

      .card-label {
        width: 100%;
        line-height: 1.2;
      }

      /* Speaker Icon */
      .card .speak-btn {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.3;
        transition: opacity 0.2s;
      }

      .card .speak-btn svg {
        width: 16px;
        height: 16px;
        fill: #333;
      }

      .card .speak-btn:hover {
        opacity: 1;
        background: rgba(0, 0, 0, 0.05);
      }

      .card:active {
        transform: translateY(3px);
        border-bottom-width: 2px;
      }

      .card.selected {
        background-color: #ddf4ff;
        border-color: var(--secondary);
        border-bottom-color: var(--secondary-dark);
        color: var(--secondary);
      }

      .card.correct {
        background-color: #d7ffb8;
        border-color: var(--primary);
        border-bottom-color: var(--primary-dark);
        color: var(--primary-dark);
        transform: scale(0.95);
        opacity: 0;
        pointer-events: none;
        transition: all 0.4s ease;
      }

      .card.wrong {
        background-color: #ffdfe0;
        border-color: var(--wrong);
        border-bottom-color: #d32f2f;
        color: var(--wrong);
        animation: shake 0.4s;
      }

      .card.entry {
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      }

      .card.has-help::after {
        content: "";
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 3px;
        background: var(--secondary);
        border-radius: 2px;
        opacity: 0.4;
      }

      /* Long press hint */
      .card.pressing {
        transform: scale(0.97);
        transition: transform 0.2s;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      /* Loading */
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999;
        gap: 12px;
        color: #888;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top-color: var(--secondary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="controls-row">
        <select id="csv-select" onchange="game.changeCsv(this.value)">
          <option value="a1.csv">A1 Vocabulary</option>
          <option value="duolingo.csv">Duolingo</option>
        </select>
        <select id="category-select" onchange="game.changeCategory(this.value)">
          <option value="all">All Categories</option>
        </select>
        <select id="lang-left" onchange="game.restart()">
          <option value="en">English</option>
          <option value="fr" selected>French</option>
          <option value="nl">Dutch</option>
        </select>
        <select id="lang-right" onchange="game.restart()">
          <option value="en" selected>English</option>
          <option value="fr">French</option>
          <option value="nl">Dutch</option>
        </select>
        <button class="reset-btn" onclick="game.resetProgress()">Reset</button>
        <button class="sheet-btn" onclick="document.querySelector('bottom-sheet').open()">â˜° Menu</button>
      </div>
    </header>

    <div class="stats-bar">
      <div class="stats-left">Mastery: <strong id="mastery-count">0</strong> / <span id="total-count">0</span></div>
      <div class="stats-right" id="percent-label">0%</div>
    </div>

    <div id="progress-container">
      <div id="progress-fill"></div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
      <div class="spinner"></div>
      <div>Loading Library...</div>
    </div>

    <div id="game-board" style="display: none">
      <div class="column" id="col-left"></div>
      <div class="column" id="col-right"></div>
    </div>

    <!-- Help Bottom Sheet -->
    <bottom-sheet id="help-sheet">
      <div style="padding: 8px 0">
        <div id="help-content">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px">
            <div id="help-word" style="font-size: 1.8rem; font-weight: 800; color: var(--secondary); flex: 1"></div>
            <button
              id="help-speak-btn"
              onclick="HelpSheet.speak()"
              style="
                width: 44px;
                height: 44px;
                border-radius: 50%;
                border: 2px solid var(--secondary);
                background: rgba(28, 176, 246, 0.1);
                color: var(--secondary);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
              "
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path
                  d="M12 4L7 9H3v6h4l5 5V4zm4.5 9c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z"
                />
              </svg>
            </button>
          </div>

          <!-- Phonetic Section -->
          <div id="help-phonetic-section" class="help-section">
            <div class="help-label">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.7">
                <path
                  d="M12 15c1.66 0 3-1.34 3-3V6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5-3c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-2.08c3.39-.49 6-3.39 6-6.92h-2z"
                />
              </svg>
              Pronunciation
            </div>
            <div id="help-phonetic" class="help-value" style="font-style: italic; color: #82e827"></div>
          </div>

          <!-- Example Sentence Section -->
          <div id="help-example-section" class="help-section">
            <div class="help-label">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.7">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z" />
              </svg>
              Example
            </div>
            <div id="help-example" class="help-value"></div>
            <div id="help-example-translation" class="help-translation"></div>
          </div>

          <!-- Grammar Section -->
          <div id="help-grammar-section" class="help-section">
            <div class="help-label">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.7">
                <path
                  d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"
                />
              </svg>
              Grammar Tip
            </div>
            <div id="help-grammar" class="help-value" style="color: #ffc107"></div>
          </div>

          <!-- No Data Message -->
          <div id="help-no-data" style="display: none; text-align: center; padding: 20px; color: #888">
            <svg
              width="48"
              height="48"
              viewBox="0 0 24 24"
              fill="currentColor"
              style="opacity: 0.3; margin-bottom: 12px"
            >
              <path
                d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"
              />
            </svg>
            <div>No additional help available for this word yet.</div>
          </div>
        </div>

        <button
          onclick="document.getElementById('help-sheet').close()"
          style="
            width: 100%;
            margin-top: 24px;
            padding: 14px;
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            font-family: inherit;
          "
        >
          Got it!
        </button>
      </div>
    </bottom-sheet>

    <style>
      .help-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 14px 16px;
        margin-bottom: 12px;
      }
      .help-label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.8rem;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }
      .help-value {
        font-size: 1.1rem;
        color: #fff;
        line-height: 1.5;
      }
      .help-translation {
        font-size: 0.9rem;
        color: #888;
        margin-top: 6px;
        font-style: italic;
      }
    </style>

    <!-- Bottom Sheet Settings -->
    <bottom-sheet id="menu-sheet">
      <div style="padding: 8px 0">
        <h2 style="margin: 0 0 16px; color: white; font-size: 1.3rem">Settings</h2>

        <div style="display: flex; flex-direction: column; gap: 12px">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 16px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 12px;
            "
          >
            <div>
              <div style="color: #fff; font-weight: 700; margin-bottom: 4px">Auto Sound</div>
              <div style="color: #888; font-size: 0.85rem">Read words aloud when clicking left cards</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="sound-toggle" onchange="Settings.setSound(this.checked)" />
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>

        <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1)">
          <p style="color: #666; font-size: 0.85rem; line-height: 1.5; margin: 0 0 10px 0">
            ðŸ’¡ Tip: You can always tap the speaker icon on any card to hear it read aloud.
          </p>
          <p style="color: #666; font-size: 0.85rem; line-height: 1.5; margin: 0">
            ðŸ“š <strong style="color: var(--secondary)">Long-press</strong> or
            <strong style="color: var(--secondary)">double-tap</strong> any card to see pronunciation, examples, and
            grammar tips!
          </p>
        </div>

        <button
          onclick="document.querySelector('bottom-sheet').close()"
          style="
            width: 100%;
            margin-top: 24px;
            padding: 14px;
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            font-family: inherit;
          "
        >
          Done
        </button>
      </div>
    </bottom-sheet>

    <!-- BottomSheet Custom Element -->
    <script>
      class BottomSheet extends HTMLElement {
        static get observedAttributes() {
          return ["open"];
        }

        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this._isOpen = false;
          this._sheetHeight = 0;
        }

        connectedCallback() {
          this.render();
          this.setupEventListeners();
          // Initial scroll position (closed)
          requestAnimationFrame(() => {
            this._scroller.scrollTop = 0;
          });
        }

        get isOpen() {
          return this._isOpen;
        }

        render() {
          this.shadowRoot.innerHTML = `
            <style>
              :host {
                --sheet-bg: #1e2a31;
                --sheet-handle: #4a5a64;
                --sheet-radius: 20px;
                --backdrop-color: rgba(0, 0, 0, 0.6);
                --sheet-max-height: 70vh;
                --sheet-transition: 0.3s;
                
                position: fixed;
                inset: 0;
                z-index: 1000;
                pointer-events: none;
              }

              /* Backdrop - opacity controlled by scroll position */
              .backdrop {
                position: fixed;
                inset: 0;
                background: var(--backdrop-color);
                opacity: 0;
                will-change: opacity;
                pointer-events: none;
                z-index: -1;
              }

              /* Main scroller - the scroll snap container */
              .scroller {
                position: absolute;
                inset: 0;
                overflow-y: scroll;
                overflow-x: hidden;
                scroll-snap-type: y mandatory;
                overscroll-behavior: contain;
                pointer-events: none;
                scrollbar-width: none;
                -ms-overflow-style: none;
              }

              .scroller::-webkit-scrollbar {
                display: none;
              }

              /* Top snap point (closed state) - transparent to clicks */
              .snap-top {
                height: 100dvh;
                scroll-snap-align: start;
                scroll-snap-stop: always;
                pointer-events: none;
              }

              /* The actual sheet */
              .sheet {
                position: relative;
                background: var(--sheet-bg);
                border-radius: var(--sheet-radius) var(--sheet-radius) 0 0;
                min-height: var(--sheet-max-height);
                max-height: var(--sheet-max-height);
                scroll-snap-align: start;
                scroll-snap-stop: always;
                display: flex;
                flex-direction: column;
                box-shadow: 0 -4px 32px rgba(0, 0, 0, 0.3);
                pointer-events: auto;
              }

              /* Drag handle */
              .handle-area {
                padding: 12px 16px 8px;
                cursor: grab;
                flex-shrink: 0;
              }

              .handle-area:active {
                cursor: grabbing;
              }

              .handle {
                width: 40px;
                height: 4px;
                background: var(--sheet-handle);
                border-radius: 2px;
                margin: 0 auto;
              }

              /* Content area */
              .content {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                overscroll-behavior: contain;
                padding: 0 16px 16px;
              }

              /* iOS Safari rubber banding fix */
              
                .content {
                  overflow-x: scroll;
                  overscroll-behavior-x: none;
                  scrollbar-width: none;
                  -webkit-overflow-scrolling: touch;
                }

                .content::-webkit-scrollbar {
                  display: none;
                }

                /* Tiny horizontal scroll to absorb rubber band */
                .content::after {
                  display: block;
                  width: calc(100% + 1px);
                  height: 1px;
                  content: "";
                  flex-shrink: 0;
                }
              

              /* Slot styling */
              ::slotted(*) {
                color: #e0e0e0;
              }
            </style>

            <div class="backdrop" part="backdrop"></div>
            <div class="scroller" part="scroller">
              <div class="snap-top" part="snap-top"></div>
              <div class="sheet" part="sheet">
                <div class="handle-area" part="handle-area">
                  <div class="handle" part="handle"></div>
                </div>
                <div class="content" part="content">
                  <slot></slot>
                </div>
              </div>
            </div>
          `;

          this._scroller = this.shadowRoot.querySelector(".scroller");
          this._sheet = this.shadowRoot.querySelector(".sheet");
          this._backdrop = this.shadowRoot.querySelector(".backdrop");
          this._snapTop = this.shadowRoot.querySelector(".snap-top");
        }

        setupEventListeners() {
          // Close on backdrop click
          this._backdrop.addEventListener("click", () => this.close());

          // Update backdrop opacity on scroll
          this._scroller.addEventListener("scroll", () => {
            this._updateBackdropOpacity();

            // Debounced state update
            clearTimeout(this._scrollTimeout);
            this._scrollTimeout = setTimeout(() => {
              this._updateOpenState();
            }, 150);
          });

          // Final state check on scroll end
          this._scroller.addEventListener("scrollend", () => {
            this._updateOpenState();
          });

          // Handle escape key
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this._isOpen) {
              this.close();
            }
          });
        }

        _updateBackdropOpacity() {
          const scrollTop = this._scroller.scrollTop;
          const maxScroll = this._snapTop.offsetHeight;
          const progress = Math.min(scrollTop / maxScroll, 1);

          this._backdrop.style.opacity = progress;
          this._backdrop.style.pointerEvents = progress > 0.1 ? "auto" : "none";
        }

        _updateOpenState() {
          const scrollTop = this._scroller.scrollTop;
          const threshold = this._snapTop.offsetHeight * 0.5;
          const wasOpen = this._isOpen;
          this._isOpen = scrollTop > threshold;

          if (wasOpen !== this._isOpen) {
            // Update pointer events based on state
            if (!this._isOpen) {
              this._scroller.style.pointerEvents = "none";
            }

            this.dispatchEvent(
              new CustomEvent(this._isOpen ? "open" : "close", {
                bubbles: true,
                composed: true,
              })
            );
          }
        }

        open() {
          if (!this._scroller) return;

          // Enable scrolling interaction
          this._scroller.style.pointerEvents = "auto";

          const targetScroll = this._snapTop.offsetHeight;
          this._scroller.scrollTo({
            top: targetScroll,
            behavior: "smooth",
          });
          this._isOpen = true;
        }

        close() {
          if (!this._scroller) return;

          this._scroller.scrollTo({
            top: 0,
            behavior: "smooth",
          });
          this._isOpen = false;

          // Disable scrolling interaction after animation
          setTimeout(() => {
            if (!this._isOpen) {
              this._scroller.style.pointerEvents = "none";
            }
          }, 350);
        }

        toggle() {
          if (this._isOpen) {
            this.close();
          } else {
            this.open();
          }
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "open") {
            if (newValue !== null) {
              this.open();
            } else {
              this.close();
            }
          }
        }
      }

      customElements.define("bottom-sheet", BottomSheet);
    </script>

    <script>
      // CSV Selection Storage
      const CsvStorage = {
        KEY: "match-up-csv-selection",

        get() {
          if (typeof Storage === "undefined") return "a1.csv";
          return localStorage.getItem(this.KEY) || "a1.csv";
        },

        set(csvFile) {
          if (typeof Storage === "undefined") return;
          localStorage.setItem(this.KEY, csvFile);
        },
      };

      // Get initial CSV from storage
      const getDataUrl = () => `./${CsvStorage.get()}`;

      const LANGUAGE_LOCALES = {
        en: "en-US",
        fr: "fr-FR",
        nl: "nl-NL",
      };

      // --- HELP SHEET ---
      const HelpSheet = {
        currentWord: null,
        currentLang: null,

        show(wordData, lang) {
          this.currentWord = wordData;
          this.currentLang = lang;

          const sheet = document.getElementById("help-sheet");
          const word = wordData[lang] || wordData.en;

          // Set the word
          document.getElementById("help-word").textContent = word;

          // Get phonetic, example, and grammar based on language
          const phoneticKey = `phonetic_${lang}`;
          const exampleKey = `example_${lang}`;
          const phonetic = wordData[phoneticKey] || "";
          const example = wordData[exampleKey] || "";
          const grammar = wordData.grammar || "";

          // Check if we have any help data
          const hasData = phonetic || example || grammar;

          // Show/hide sections
          document.getElementById("help-no-data").style.display = hasData ? "none" : "block";
          document.getElementById("help-phonetic-section").style.display = phonetic ? "block" : "none";
          document.getElementById("help-example-section").style.display = example ? "block" : "none";
          document.getElementById("help-grammar-section").style.display = grammar ? "block" : "none";

          // Fill in data
          if (phonetic) {
            document.getElementById("help-phonetic").textContent = `/${phonetic}/`;
          }

          if (example) {
            document.getElementById("help-example").textContent = example;
            // Show English translation if available
            const enExample = wordData.example_en || "";
            document.getElementById("help-example-translation").textContent = enExample ? `â†’ ${enExample}` : "";
          }

          if (grammar) {
            document.getElementById("help-grammar").textContent = grammar;
          }

          sheet.open();
        },

        speak() {
          if (!this.currentWord || !this.currentLang) return;
          const text = this.currentWord[this.currentLang] || this.currentWord.en;
          speakText(text, this.currentLang);
        },
      };

      // --- LONG PRESS & DOUBLE TAP HANDLER ---
      const GestureHandler = {
        // Long press settings
        LONG_PRESS_DURATION: 500,
        MOVE_THRESHOLD: 10,

        // Double tap settings
        DOUBLE_TAP_DELAY: 300,

        attach(element, callback) {
          let longPressTimer = null;
          let startX = 0;
          let startY = 0;
          let lastTapTime = 0;
          let tapCount = 0;
          let tapTimer = null;

          // Long press detection
          element.addEventListener("pointerdown", (e) => {
            startX = e.clientX;
            startY = e.clientY;
            longPressTimer = setTimeout(() => {
              callback(e);
              element.dataset.longPressed = "true";
            }, this.LONG_PRESS_DURATION);
          });

          element.addEventListener("pointerup", () => {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });

          element.addEventListener("pointerleave", () => {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });

          element.addEventListener("pointermove", (e) => {
            if (!longPressTimer) return;
            const dx = Math.abs(e.clientX - startX);
            const dy = Math.abs(e.clientY - startY);
            if (dx > this.MOVE_THRESHOLD || dy > this.MOVE_THRESHOLD) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });

          // Double tap detection (for iOS)
          element.addEventListener("click", (e) => {
            const now = Date.now();

            if (now - lastTapTime < this.DOUBLE_TAP_DELAY) {
              // Double tap detected!
              tapCount++;
              if (tapCount === 2) {
                e.preventDefault();
                e.stopPropagation();
                callback(e);
                element.dataset.longPressed = "true";
                tapCount = 0;
                if (tapTimer) clearTimeout(tapTimer);
              }
            } else {
              tapCount = 1;
            }

            lastTapTime = now;

            // Reset tap count after delay
            if (tapTimer) clearTimeout(tapTimer);
            tapTimer = setTimeout(() => {
              tapCount = 0;
            }, this.DOUBLE_TAP_DELAY);
          });

          element.addEventListener("contextmenu", (e) => e.preventDefault());
        },
      };

      // --- PERSISTENCE ---
      const Storage = {
        KEY: "matchup_mastered_ids",
        // Get Set of mastered IDs
        load() {
          try {
            const raw = localStorage.getItem(this.KEY);
            return new Set(raw ? JSON.parse(raw) : []);
          } catch (e) {
            return new Set();
          }
        },
        // Save ID
        add(id) {
          const s = this.load();
          s.add(id);
          localStorage.setItem(this.KEY, JSON.stringify([...s]));
        },
        // Clear all progress
        clear() {
          localStorage.removeItem(this.KEY);
        },
      };

      // --- SETTINGS ---
      const Settings = {
        KEY: "matchup_settings",
        _cache: null,

        load() {
          if (this._cache) return this._cache;
          try {
            const raw = localStorage.getItem(this.KEY);
            this._cache = raw ? JSON.parse(raw) : { sound: true };
          } catch (e) {
            this._cache = { sound: true };
          }
          return this._cache;
        },

        save() {
          localStorage.setItem(this.KEY, JSON.stringify(this._cache));
        },

        getSound() {
          return this.load().sound;
        },

        setSound(value) {
          this.load().sound = value;
          this.save();
        },

        init() {
          const settings = this.load();
          const toggle = document.getElementById("sound-toggle");
          if (toggle) {
            toggle.checked = settings.sound;
          }
        },
      };

      // --- TTS ---
      const CAN_USE_SPEECH = typeof window !== "undefined" && "speechSynthesis" in window;
      let speechVoices = [];
      if (CAN_USE_SPEECH) {
        window.speechSynthesis.onvoiceschanged = () => {
          speechVoices = window.speechSynthesis.getVoices();
        };
      }

      function speakText(text, langCode) {
        if (!text || !CAN_USE_SPEECH) return;
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        const locale = LANGUAGE_LOCALES[langCode] || langCode;
        utterance.lang = locale;
        utterance.rate = 0.9; // Slightly slower for learning

        // Voice selection heuristics
        const voice = speechVoices.find((v) => v.lang.startsWith(locale.split("-")[0]));
        if (voice) utterance.voice = voice;

        window.speechSynthesis.speak(utterance);
      }

      // --- FETCH ---
      class DataFetcher {
        static async loadData(url) {
          try {
            const response = await fetch(url);
            const text = await response.text();
            return this.csvToJson(text);
          } catch (error) {
            console.error(error);
            alert("Connection error. Using offline mode if available.");
            return [];
          }
        }

        static csvToJson(csv) {
          const lines = csv.trim().split("\n");
          const headers = lines[0].split(",").map((h) => h.trim());
          const result = [];

          // Required columns (must have at least these)
          const requiredCount = 4; // id, en, fr, nl

          for (let i = 1; i < lines.length; i++) {
            const currentline = lines[i].split(",");
            // Only require the first 4 columns (id, en, fr, nl), rest are optional
            if (currentline.length < requiredCount) continue;

            const obj = {};
            headers.forEach((header, index) => {
              obj[header] = currentline[index] ? currentline[index].trim() : "";
            });

            if (!obj.id || obj.id.toLowerCase() === "id" || !obj.en) {
              continue;
            }

            // Categorize by first part of ID (e.g. 'food_item_1' -> 'food')
            obj.category = obj.id.split("_")[0];
            result.push(obj);
          }
          return result;
        }
      }

      // --- GAME CLASS ---
      class MatchGame {
        constructor() {
          this.fullData = [];
          this.activeData = [];
          this.categories = new Set();
          this.masteredSet = Storage.load(); // Load mastery from memory
          this.currentCsv = CsvStorage.get();

          this.selectedLeft = null;
          this.selectedRight = null;
          this.maxPairs = 10;
          this.pairsOnBoard = 0;

          // UI Refs
          this.elMastery = document.getElementById("mastery-count");
          this.elTotal = document.getElementById("total-count");
          this.elPercent = document.getElementById("percent-label");
          this.elProgressFill = document.getElementById("progress-fill");

          // Set initial CSV selection
          const csvSelect = document.getElementById("csv-select");
          if (csvSelect) {
            csvSelect.value = this.currentCsv;
          }

          this.init();
        }

        async init() {
          // Show loading overlay
          document.getElementById("loading-overlay").style.display = "flex";
          document.getElementById("game-board").style.display = "none";

          // Lazy load CSV data
          const dataUrl = getDataUrl();
          this.fullData = await DataFetcher.loadData(dataUrl);

          if (!this.fullData.length) {
            document.getElementById("loading-overlay").style.display = "none";
            alert("Failed to load data. Please check the CSV file.");
            return;
          }

          // Initialize Settings
          Settings.init();

          // Setup Categories
          this.categories.clear();
          this.fullData.forEach((item) => this.categories.add(item.category));
          this.populateCategorySelect();

          // Prepare Board
          this.createSlots();
          document.getElementById("loading-overlay").style.display = "none";
          document.getElementById("game-board").style.display = "grid";

          // Start
          this.activeData = [...this.fullData];
          this.updateGlobalProgress();
          this.startRound();
        }

        async changeCsv(csvFile) {
          if (csvFile === this.currentCsv) return;

          this.currentCsv = csvFile;
          CsvStorage.set(csvFile);

          // Reload game with new CSV
          await this.init();
        }

        createSlots() {
          const leftCol = document.getElementById("col-left");
          const rightCol = document.getElementById("col-right");

          // Clear existing slots if any
          leftCol.innerHTML = "";
          rightCol.innerHTML = "";

          for (let i = 0; i < this.maxPairs; i++) {
            const l = document.createElement("div");
            l.className = "card-slot";
            leftCol.appendChild(l);
            const r = document.createElement("div");
            r.className = "card-slot";
            rightCol.appendChild(r);
          }
          this.elLeft = document.querySelectorAll("#col-left .card-slot");
          this.elRight = document.querySelectorAll("#col-right .card-slot");
        }

        populateCategorySelect() {
          const select = document.getElementById("category-select");

          // Clear existing options except "All Categories"
          const allOption = select.querySelector('option[value="all"]');
          select.innerHTML = "";
          if (allOption) {
            select.appendChild(allOption);
          } else {
            const opt = document.createElement("option");
            opt.value = "all";
            opt.innerText = "All Categories";
            select.appendChild(opt);
          }

          // Add category options
          const sorted = Array.from(this.categories).sort();
          sorted.forEach((cat) => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.innerText = cat
              .split("_")
              .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
              .join(" ");
            select.appendChild(opt);
          });
        }

        changeCategory(cat) {
          if (cat === "all") {
            this.activeData = [...this.fullData];
          } else {
            this.activeData = this.fullData.filter((item) => item.category === cat);
          }
          this.updateGlobalProgress();
          this.startRound();
        }

        restart() {
          this.startRound();
        }

        resetProgress() {
          if (!confirm("Are you sure you want to reset all progress? This cannot be undone.")) {
            return;
          }
          Storage.clear();
          this.masteredSet = new Set();
          this.updateGlobalProgress();
          this.startRound();
        }

        updateGlobalProgress() {
          // Calculate stats based on Active Data (Category)
          const totalItems = this.activeData.length;
          // Count how many of the active items are in the mastered set
          const masteredCount = this.activeData.filter((item) => this.masteredSet.has(item.id)).length;

          const percent = totalItems === 0 ? 0 : Math.round((masteredCount / totalItems) * 100);

          this.elMastery.innerText = masteredCount;
          this.elTotal.innerText = totalItems;
          this.elPercent.innerText = percent + "%";
          this.elProgressFill.style.width = percent + "%";
        }

        startRound() {
          // Clear slots
          this.elLeft.forEach((s) => (s.innerHTML = ""));
          this.elRight.forEach((s) => (s.innerHTML = ""));
          this.selectedLeft = null;
          this.selectedRight = null;

          if (this.activeData.length === 0) return;

          // Deck Building Strategy:
          // 1. Prioritize unmastered words (Learning)
          // 2. Fill rest with mastered words (Review)
          const unmastered = this.activeData.filter((w) => !this.masteredSet.has(w.id));
          const mastered = this.activeData.filter((w) => this.masteredSet.has(w.id));

          // Shuffle both
          unmastered.sort(() => 0.5 - Math.random());
          mastered.sort(() => 0.5 - Math.random());

          let deck = [];

          // Try to take new words and review words (or whatever is available)
          if (unmastered.length > 0) {
            deck.push(...unmastered.slice(0, this.maxPairs));
            // If we didn't fill maxPairs, add from mastered
            if (deck.length < this.maxPairs) {
              deck.push(...mastered.slice(0, this.maxPairs - deck.length));
            }
          } else {
            // Mastery 100% -> Just review random cards
            deck = mastered.slice(0, this.maxPairs);
          }

          // Randomize the final hand
          deck.sort(() => 0.5 - Math.random());

          this.pairsOnBoard = deck.length;

          const lefts = [...deck];
          const rights = [...deck].sort(() => 0.5 - Math.random()); // Shuffle right side

          lefts.forEach((item, i) => this.renderCard(this.elLeft[i], item, "left"));
          rights.forEach((item, i) => this.renderCard(this.elRight[i], item, "right"));
        }

        renderCard(slot, word, side) {
          if (!slot || !word) return;
          const lang =
            side === "left" ? document.getElementById("lang-left").value : document.getElementById("lang-right").value;
          const text = word[lang] || word.en;

          const card = document.createElement("div");
          card.className = "card entry";
          card.dataset.id = word.id;
          card.dataset.side = side;

          card.innerHTML = `<span class="card-label">${text}</span>`;

          const btn = document.createElement("button");
          btn.className = "speak-btn";
          btn.innerHTML =
            '<svg viewBox="0 0 24 24"><path d="M12 4L7 9H3v6h4l5 5V4zm4.5 9c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z"/></svg>';
          btn.onclick = (e) => {
            e.stopPropagation();
            speakText(text, lang);
          };
          card.appendChild(btn);

          // Check if word has help data
          const hasHelp = word[`phonetic_${lang}`] || word[`example_${lang}`] || word.grammar;
          if (hasHelp) {
            card.classList.add("has-help");
          }

          // Long press or double tap for help
          GestureHandler.attach(card, (e) => {
            e.stopPropagation();
            card.classList.remove("pressing");
            HelpSheet.show(word, lang);
            // Haptic feedback if available
            if (navigator.vibrate) navigator.vibrate(50);
          });

          // Visual feedback during press
          card.addEventListener("pointerdown", () => card.classList.add("pressing"));
          card.addEventListener("pointerup", () => card.classList.remove("pressing"));
          card.addEventListener("pointerleave", () => card.classList.remove("pressing"));

          card.onclick = (e) => {
            // Skip if this was a long press
            if (card.dataset.longPressed === "true") {
              card.dataset.longPressed = "false";
              return;
            }
            this.handleCardClick(card);
          };
          slot.appendChild(card);
        }

        handleCardClick(card) {
          if (card.classList.contains("correct") || card.classList.contains("wrong")) return;

          const isLeft = card.dataset.side === "left";
          const current = isLeft ? this.selectedLeft : this.selectedRight;

          if (current) current.classList.remove("selected");
          card.classList.add("selected");

          if (isLeft) {
            this.selectedLeft = card;
            // Auto-speak left cards when sound is enabled
            if (Settings.getSound()) {
              const text = card.querySelector(".card-label").textContent;
              const lang = document.getElementById("lang-left").value;
              speakText(text, lang);
            }
          } else {
            this.selectedRight = card;
          }

          if (this.selectedLeft && this.selectedRight) this.checkMatch();
        }

        checkMatch() {
          const l = this.selectedLeft;
          const r = this.selectedRight;
          const id = l.dataset.id;

          if (l.dataset.id === r.dataset.id) {
            // Correct
            l.classList.add("correct");
            r.classList.add("correct");
            l.classList.remove("selected");
            r.classList.remove("selected");

            // --- PROGRESS UPDATE ---
            if (!this.masteredSet.has(id)) {
              Storage.add(id); // Save to local storage
              this.masteredSet.add(id); // Update memory
              this.updateGlobalProgress(); // Update Bar
            }

            this.pairsOnBoard--;
            this.selectedLeft = null;
            this.selectedRight = null;

            if (this.pairsOnBoard === 0) {
              setTimeout(() => this.startRound(), 600);
            }
          } else {
            // Wrong
            l.classList.add("wrong");
            r.classList.add("wrong");
            setTimeout(() => {
              l.classList.remove("wrong", "selected");
              r.classList.remove("wrong", "selected");
              this.selectedLeft = null;
              this.selectedRight = null;
            }, 500);
          }
        }
      }

      const game = new MatchGame();
    </script>
  </body>
</html>
