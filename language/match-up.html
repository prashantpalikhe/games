<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Match-Up: Mastery</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet" />
    <style>
      :root {
        --primary: #58cc02;
        --primary-dark: #46a302;
        --secondary: #1cb0f6;
        --secondary-dark: #1899d6;
        --wrong: #ff4b4b;
        --bg: #131f24;
        --card-bg: #ffffff;
        --text: #4b4b4b;
        --border: #e5e5e5;
      }

      body {
        font-family: "Nunito", sans-serif;
        background-color: var(--bg);
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        margin: 0;
        padding: 10px;
        overflow: hidden;
      }

      /* --- Header & Controls --- */
      header {
        width: 100%;
        max-width: 600px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 10px 5px;
      }

      .controls-row {
        display: flex;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      select {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #37464f;
        background: #131f24;
        color: #afafaf;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
      }

      select:hover {
        border-color: #52656d;
        color: white;
      }

      .reset-btn {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #5c3a3a;
        background: #131f24;
        color: #c47070;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
        transition: all 0.2s;
      }

      .reset-btn:hover {
        border-color: var(--wrong);
        color: var(--wrong);
        background: rgba(255, 75, 75, 0.1);
      }

      #category-select {
        border-color: var(--secondary-dark);
        color: var(--secondary);
        min-width: 160px;
      }

      /* --- Progress Section --- */
      .stats-bar {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        font-size: 0.9rem;
        color: #b0bec5;
        margin-bottom: 4px;
      }

      .stats-left strong {
        color: var(--primary);
      }

      #progress-container {
        width: 100%;
        max-width: 500px;
        height: 14px;
        background: #37464f;
        border-radius: 99px;
        margin: 0 auto 15px auto;
        overflow: hidden;
        border: 2px solid #263238;
      }

      #progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--primary), #82e827);
        transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: 0 0 10px rgba(88, 204, 2, 0.4);
      }

      /* --- Game Board --- */
      #game-board {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        width: 100%;
        max-width: 500px;
        height: 100%;
        align-content: start;
        padding-bottom: 20px;
      }

      .column {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .card-slot {
        height: 60px;
        position: relative;
      }

      .card {
        position: absolute;
        inset: 0;
        background-color: var(--card-bg);
        border: 2px solid var(--border);
        border-bottom: 5px solid var(--border);
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 800;
        color: var(--text);
        user-select: none;
        touch-action: manipulation;
        transition: transform 0.1s, border-bottom 0.1s;
        padding: 0 34px 0 12px; /* Space for speaker icon */
        z-index: 10;
      }

      .card-label {
        width: 100%;
        line-height: 1.2;
      }

      /* Speaker Icon */
      .card .speak-btn {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.3;
        transition: opacity 0.2s;
      }

      .card .speak-btn svg {
        width: 16px;
        height: 16px;
        fill: #333;
      }

      .card .speak-btn:hover {
        opacity: 1;
        background: rgba(0, 0, 0, 0.05);
      }

      .card:active {
        transform: translateY(3px);
        border-bottom-width: 2px;
      }

      .card.selected {
        background-color: #ddf4ff;
        border-color: var(--secondary);
        border-bottom-color: var(--secondary-dark);
        color: var(--secondary);
      }

      .card.correct {
        background-color: #d7ffb8;
        border-color: var(--primary);
        border-bottom-color: var(--primary-dark);
        color: var(--primary-dark);
        transform: scale(0.95);
        opacity: 0;
        pointer-events: none;
        transition: all 0.4s ease;
      }

      .card.wrong {
        background-color: #ffdfe0;
        border-color: var(--wrong);
        border-bottom-color: #d32f2f;
        color: var(--wrong);
        animation: shake 0.4s;
      }

      .card.entry {
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      /* Loading */
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999;
        gap: 12px;
        color: #888;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top-color: var(--secondary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="controls-row">
        <select id="category-select" onchange="game.changeCategory(this.value)">
          <option value="all">All Categories</option>
        </select>
        <select id="lang-left" onchange="game.restart()">
          <option value="en">English</option>
          <option value="fr" selected>French</option>
          <option value="nl">Dutch</option>
        </select>
        <select id="lang-right" onchange="game.restart()">
          <option value="en" selected>English</option>
          <option value="fr">French</option>
          <option value="nl">Dutch</option>
        </select>
        <button class="reset-btn" onclick="game.resetProgress()">Reset</button>
      </div>
    </header>

    <div class="stats-bar">
      <div class="stats-left">Mastery: <strong id="mastery-count">0</strong> / <span id="total-count">0</span></div>
      <div class="stats-right" id="percent-label">0%</div>
    </div>

    <div id="progress-container">
      <div id="progress-fill"></div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
      <div class="spinner"></div>
      <div>Loading Library...</div>
    </div>

    <div id="game-board" style="display: none">
      <div class="column" id="col-left"></div>
      <div class="column" id="col-right"></div>
    </div>

    <script>
      const DATA_URL = "./a1.csv";

      const LANGUAGE_LOCALES = {
        en: "en-US",
        fr: "fr-FR",
        nl: "nl-NL",
      };

      // --- PERSISTENCE ---
      const Storage = {
        KEY: "matchup_mastered_ids",
        // Get Set of mastered IDs
        load() {
          try {
            const raw = localStorage.getItem(this.KEY);
            return new Set(raw ? JSON.parse(raw) : []);
          } catch (e) {
            return new Set();
          }
        },
        // Save ID
        add(id) {
          const s = this.load();
          s.add(id);
          localStorage.setItem(this.KEY, JSON.stringify([...s]));
        },
        // Clear all progress
        clear() {
          localStorage.removeItem(this.KEY);
        },
      };

      // --- TTS ---
      const CAN_USE_SPEECH = typeof window !== "undefined" && "speechSynthesis" in window;
      let speechVoices = [];
      if (CAN_USE_SPEECH) {
        window.speechSynthesis.onvoiceschanged = () => {
          speechVoices = window.speechSynthesis.getVoices();
        };
      }

      function speakText(text, langCode) {
        if (!text || !CAN_USE_SPEECH) return;
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        const locale = LANGUAGE_LOCALES[langCode] || langCode;
        utterance.lang = locale;
        utterance.rate = 0.9; // Slightly slower for learning

        // Voice selection heuristics
        const voice = speechVoices.find((v) => v.lang.startsWith(locale.split("-")[0]));
        if (voice) utterance.voice = voice;

        window.speechSynthesis.speak(utterance);
      }

      // --- FETCH ---
      class DataFetcher {
        static async loadData(url) {
          try {
            const response = await fetch(url);
            const text = await response.text();
            return this.csvToJson(text);
          } catch (error) {
            console.error(error);
            alert("Connection error. Using offline mode if available.");
            return [];
          }
        }

        static csvToJson(csv) {
          const lines = csv.trim().split("\n");
          const headers = lines[0].split(",").map((h) => h.trim());
          const result = [];

          for (let i = 1; i < lines.length; i++) {
            const currentline = lines[i].split(",");
            if (currentline.length < headers.length) continue;

            const obj = {};
            headers.forEach((header, index) => {
              obj[header] = currentline[index] ? currentline[index].trim() : "";
            });

            if (!obj.id || obj.id.toLowerCase() === "id" || !obj.en) {
              continue;
            }

            // Categorize by first part of ID (e.g. 'food_item_1' -> 'food')
            obj.category = obj.id.split("_")[0];
            result.push(obj);
          }
          return result;
        }
      }

      // --- GAME CLASS ---
      class MatchGame {
        constructor() {
          this.fullData = [];
          this.activeData = [];
          this.categories = new Set();
          this.masteredSet = Storage.load(); // Load mastery from memory

          this.selectedLeft = null;
          this.selectedRight = null;
          this.maxPairs = 5;
          this.pairsOnBoard = 0;

          // UI Refs
          this.elMastery = document.getElementById("mastery-count");
          this.elTotal = document.getElementById("total-count");
          this.elPercent = document.getElementById("percent-label");
          this.elProgressFill = document.getElementById("progress-fill");

          this.init();
        }

        async init() {
          this.fullData = await DataFetcher.loadData(DATA_URL);
          if (!this.fullData.length) return;

          // Setup Categories
          this.fullData.forEach((item) => this.categories.add(item.category));
          this.populateCategorySelect();

          // Prepare Board
          this.createSlots();
          document.getElementById("loading-overlay").style.display = "none";
          document.getElementById("game-board").style.display = "grid";

          // Start
          this.activeData = [...this.fullData];
          this.updateGlobalProgress();
          this.startRound();
        }

        createSlots() {
          const leftCol = document.getElementById("col-left");
          const rightCol = document.getElementById("col-right");
          for (let i = 0; i < this.maxPairs; i++) {
            const l = document.createElement("div");
            l.className = "card-slot";
            leftCol.appendChild(l);
            const r = document.createElement("div");
            r.className = "card-slot";
            rightCol.appendChild(r);
          }
          this.elLeft = document.querySelectorAll("#col-left .card-slot");
          this.elRight = document.querySelectorAll("#col-right .card-slot");
        }

        populateCategorySelect() {
          const select = document.getElementById("category-select");
          const sorted = Array.from(this.categories).sort();
          sorted.forEach((cat) => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.innerText = cat
              .split("_")
              .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
              .join(" ");
            select.appendChild(opt);
          });
        }

        changeCategory(cat) {
          if (cat === "all") {
            this.activeData = [...this.fullData];
          } else {
            this.activeData = this.fullData.filter((item) => item.category === cat);
          }
          this.updateGlobalProgress();
          this.startRound();
        }

        restart() {
          this.startRound();
        }

        resetProgress() {
          if (!confirm("Are you sure you want to reset all progress? This cannot be undone.")) {
            return;
          }
          Storage.clear();
          this.masteredSet = new Set();
          this.updateGlobalProgress();
          this.startRound();
        }

        updateGlobalProgress() {
          // Calculate stats based on Active Data (Category)
          const totalItems = this.activeData.length;
          // Count how many of the active items are in the mastered set
          const masteredCount = this.activeData.filter((item) => this.masteredSet.has(item.id)).length;

          const percent = totalItems === 0 ? 0 : Math.round((masteredCount / totalItems) * 100);

          this.elMastery.innerText = masteredCount;
          this.elTotal.innerText = totalItems;
          this.elPercent.innerText = percent + "%";
          this.elProgressFill.style.width = percent + "%";
        }

        startRound() {
          // Clear slots
          this.elLeft.forEach((s) => (s.innerHTML = ""));
          this.elRight.forEach((s) => (s.innerHTML = ""));
          this.selectedLeft = null;
          this.selectedRight = null;

          if (this.activeData.length === 0) return;

          // Deck Building Strategy:
          // 1. Prioritize unmastered words (Learning)
          // 2. Fill rest with mastered words (Review)
          const unmastered = this.activeData.filter((w) => !this.masteredSet.has(w.id));
          const mastered = this.activeData.filter((w) => this.masteredSet.has(w.id));

          // Shuffle both
          unmastered.sort(() => 0.5 - Math.random());
          mastered.sort(() => 0.5 - Math.random());

          let deck = [];

          // Try to take 3 new words and 2 review words (or whatever is available)
          if (unmastered.length > 0) {
            deck.push(...unmastered.slice(0, 5));
            // If we didn't fill 5, add from mastered
            if (deck.length < 5) {
              deck.push(...mastered.slice(0, 5 - deck.length));
            }
          } else {
            // Mastery 100% -> Just review random cards
            deck = mastered.slice(0, 5);
          }

          // Randomize the final hand
          deck.sort(() => 0.5 - Math.random());

          this.pairsOnBoard = deck.length;

          const lefts = [...deck];
          const rights = [...deck].sort(() => 0.5 - Math.random()); // Shuffle right side

          lefts.forEach((item, i) => this.renderCard(this.elLeft[i], item, "left"));
          rights.forEach((item, i) => this.renderCard(this.elRight[i], item, "right"));
        }

        renderCard(slot, word, side) {
          if (!slot || !word) return;
          const lang =
            side === "left" ? document.getElementById("lang-left").value : document.getElementById("lang-right").value;
          const text = word[lang] || word.en;

          const card = document.createElement("div");
          card.className = "card entry";
          card.dataset.id = word.id;
          card.dataset.side = side;

          card.innerHTML = `<span class="card-label">${text}</span>`;

          const btn = document.createElement("button");
          btn.className = "speak-btn";
          btn.innerHTML =
            '<svg viewBox="0 0 24 24"><path d="M12 4L7 9H3v6h4l5 5V4zm4.5 9c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z"/></svg>';
          btn.onclick = (e) => {
            e.stopPropagation();
            speakText(text, lang);
          };
          card.appendChild(btn);

          card.onclick = () => this.handleCardClick(card);
          slot.appendChild(card);
        }

        handleCardClick(card) {
          if (card.classList.contains("correct") || card.classList.contains("wrong")) return;

          const isLeft = card.dataset.side === "left";
          const current = isLeft ? this.selectedLeft : this.selectedRight;

          if (current) current.classList.remove("selected");
          card.classList.add("selected");

          if (isLeft) this.selectedLeft = card;
          else this.selectedRight = card;

          if (this.selectedLeft && this.selectedRight) this.checkMatch();
        }

        checkMatch() {
          const l = this.selectedLeft;
          const r = this.selectedRight;
          const id = l.dataset.id;

          if (l.dataset.id === r.dataset.id) {
            // Correct
            l.classList.add("correct");
            r.classList.add("correct");
            l.classList.remove("selected");
            r.classList.remove("selected");

            // --- PROGRESS UPDATE ---
            if (!this.masteredSet.has(id)) {
              Storage.add(id); // Save to local storage
              this.masteredSet.add(id); // Update memory
              this.updateGlobalProgress(); // Update Bar
            }

            this.pairsOnBoard--;
            this.selectedLeft = null;
            this.selectedRight = null;

            if (this.pairsOnBoard === 0) {
              setTimeout(() => this.startRound(), 600);
            }
          } else {
            // Wrong
            l.classList.add("wrong");
            r.classList.add("wrong");
            setTimeout(() => {
              l.classList.remove("wrong", "selected");
              r.classList.remove("wrong", "selected");
              this.selectedLeft = null;
              this.selectedRight = null;
            }, 500);
          }
        }
      }

      const game = new MatchGame();
    </script>
  </body>
</html>
