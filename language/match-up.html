<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Duolingo Style Match - SRS Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet" />
    <style>
      :root {
        --primary: #58cc02;
        --primary-border: #46a302;
        --secondary: #1cb0f6;
        --secondary-border: #1899d6;
        --wrong: #ff4b4b;
        --wrong-border: #ea2b2b;
        --bg: #131f24;
        --card-bg: #ffffff;
        --text: #4b4b4b;
        --border: #e5e5e5;
      }

      body {
        font-family: "Nunito", sans-serif;
        background-color: var(--bg);
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        margin: 0;
        padding: 10px;
        overflow: hidden;
      }

      .loading-overlay {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999;
        gap: 12px;
      }

      .spinner {
        width: 64px;
        height: 64px;
        border: 6px solid rgba(255, 255, 255, 0.1);
        border-top-color: var(--secondary);
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      header {
        width: 100%;
        max-width: 500px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 10px 5px;
      }

      .meta-panel {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
      }

      .level-cluster {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .streak-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #24181f;
        color: #ffae42;
        padding: 4px 12px;
        border-radius: 18px;
        border: 2px solid #3b262f;
        font-weight: 800;
        font-size: 0.95rem;
      }

      .streak-pill .flame {
        font-size: 1rem;
        line-height: 1;
      }

      .controls select {
        padding: 8px 12px;
        border-radius: 12px;
        border: 2px solid #37464f;
        background: #131f24;
        color: #afafaf;
        font-family: "Nunito", sans-serif;
        font-weight: 700;
        cursor: pointer;
        outline: none;
      }

      .score-pill {
        background: #2b3b45;
        color: var(--primary);
        padding: 6px 16px;
        border-radius: 20px;
        font-weight: 800;
        font-size: 1.1rem;
        border: 2px solid #37464f;
      }

      .level-pill {
        background: #19262d;
        color: #ffe082;
        padding: 4px 12px;
        border-radius: 18px;
        font-weight: 800;
        font-size: 0.95rem;
        border: 2px solid #2a3b45;
      }

      .icon-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 2px solid #2a3b45;
        background: #17232a;
        color: white;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.15s ease;
      }

      .icon-btn svg {
        width: 14px;
        height: 14px;
        fill: #7ed4ff;
      }

      .icon-btn:hover {
        transform: translateY(-1px);
        border-color: var(--secondary);
      }

      #level-gauge {
        width: 100%;
        max-width: 500px;
        background: #152128;
        border: 1px solid #22343f;
        padding: 12px 16px;
        margin-bottom: 16px;
      }

      .level-meta {
        display: flex;
        justify-content: space-between;
        font-size: 0.85rem;
        color: #d8d8d8;
        margin-bottom: 8px;
      }

      .level-progress {
        width: 100%;
        height: 10px;
        background: #0d171d;
        border-radius: 999px;
        overflow: hidden;
      }

      #level-progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--secondary), #66d8ff);
        transition: width 0.3s ease;
      }

      #progress-container {
        width: 100%;
        max-width: 500px;
        height: 12px;
        background: #37464f;
        border-radius: 6px;
        margin-bottom: 20px;
        overflow: hidden;
      }

      #progress-fill {
        height: 100%;
        width: 0%;
        background-color: var(--primary);
        transition: width 0.3s ease;
      }

      #game-board {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        width: 100%;
        max-width: 500px;
        height: 100%;
        align-content: center;
      }

      .column {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .card-slot {
        height: 60px;
        position: relative;
      }

      .card {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--card-bg);
        border: 2px solid var(--border);
        border-bottom: 5px solid var(--border);
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 800;
        color: var(--text);
        user-select: none;
        touch-action: manipulation;
        transition: transform 0.1s, border-bottom 0.1s;
        padding: 0 12px;
      }

      .card-label {
        display: inline-block;
        width: 100%;
        padding: 0 18px;
        font-size: 1rem;
        text-align: center;
      }
      .card .speak-btn {
        position: absolute;
        top: 6px;
        right: 6px;
        width: 26px;
        height: 26px;
        border-radius: 50%;
        border: 2px solid transparent;
        background: rgba(20, 32, 38, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .card .speak-btn svg {
        width: 12px;
        height: 12px;
        fill: #9bd3ff;
      }

      .card .speak-btn:hover {
        background: rgba(28, 176, 246, 0.2);
        border-color: var(--secondary);
      }

      .card .speak-btn:focus-visible {
        outline: 2px solid var(--secondary);
      }

      .card:active {
        transform: translateY(3px);
        border-bottom-width: 2px;
      }

      .card.selected {
        background-color: #ddf4ff;
        border-color: var(--secondary);
        border-bottom-color: var(--secondary-border);
        color: var(--secondary);
      }

      .card.correct {
        background-color: #d7ffb8;
        border-color: var(--primary);
        border-bottom-color: var(--primary-border);
        color: var(--primary-border);
        transform: scale(0.9);
        opacity: 0;
        transition: all 0.3s ease-out;
        pointer-events: none;
      }

      .card.wrong {
        background-color: #ffdfe0;
        border-color: var(--wrong);
        border-bottom-color: var(--wrong-border);
        color: var(--wrong);
        animation: shake 0.4s;
      }

      .card.entry {
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      #loading {
        position: absolute;
        top: 50%;
        font-size: 1.5rem;
        color: #afafaf;
      }

      /* --- Footer for Data Management --- */
      footer {
        width: 100%;
        max-width: 500px;
        margin-top: 10px;
        display: flex;
        justify-content: center;
        gap: 8px;
        position: relative;
        top: -16px;
      }

      .reset-btn {
        background: linear-gradient(135deg, #2b3b45, #1a252c);
        color: #f4f4f4;
        border: 2px solid #3b4c56;
        padding: 8px 18px;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 700;
        cursor: pointer;
        letter-spacing: 0.5px;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .reset-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      }
    </style>
  </head>
  <body>
    <header>
      <div class="controls">
        <select id="lang-left" onchange="game.restart()">
          <option value="en">English</option>
          <option value="fr" selected>French</option>
          <option value="nl">Dutch</option>
        </select>
        <select id="lang-right" onchange="game.restart()">
          <option value="en" selected>English</option>
          <option value="fr">French</option>
          <option value="nl">Dutch</option>
        </select>
      </div>
      <div class="meta-panel">
        <div class="score-pill">
          <span id="score">0</span>
        </div>
        <div class="streak-pill">
          <span class="flame" aria-hidden="true">ðŸ”¥</span>
          <span id="streak-value">0</span>d streak
        </div>
        <div class="level-cluster">
          <div class="level-pill">Lvl <span id="level-value">1</span></div>
          <button class="icon-btn" onclick="shareLevel()" aria-label="Share level">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M18 2a3 3 0 0 0-3 3c0 .2 0 .4.1.6l-6.2 3.1a3 3 0 0 0-2.7-1.7 3 3 0 1 0 2.9 3.8l6.2 3.1A3 3 0 0 0 18 22a3 3 0 1 0-2.9-3.7l-6.2-3.2a3 3 0 0 0 .1-1l6.1-3.1A3 3 0 1 0 18 2Z"
              />
            </svg>
          </button>
        </div>
      </div>
    </header>

    <div id="level-gauge">
      <div class="level-meta">
        <span id="level-label">Level 1</span>
        <span id="xp-label">0 / 100 XP</span>
      </div>
      <div class="level-progress">
        <div id="level-progress-fill"></div>
      </div>
    </div>

    <div id="progress-container">
      <div id="progress-fill"></div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
      <div class="spinner" role="status" aria-live="polite"></div>
      <div aria-hidden="true">Warming up your vocab...</div>
    </div>

    <div id="game-board" style="display: none">
      <div class="column" id="col-left">
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
      </div>
      <div class="column" id="col-right">
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
        <div class="card-slot"></div>
      </div>
    </div>

    <footer>
      <button class="reset-btn" onclick="progressManager.resetData()">Reset Learning Progress</button>
    </footer>

    <script>
      const SHEET_URL =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vRjcd53W_88YmFTRYvjNWvR9VPfs00fOUMBKpOj14_peyipfGb7bl5maHlKpLvIEtkv8bDvrMt5Bud6/pub?output=csv";
      const XP_PER_MATCH = 15;
      const LANGUAGE_LOCALES = {
        en: "en-US",
        fr: "fr-FR",
        nl: "nl-NL",
      };
      const CAN_USE_SPEECH =
        typeof window !== "undefined" && "speechSynthesis" in window && "SpeechSynthesisUtterance" in window;
      let speechSupportWarned = false;
      let speechVoices = [];

      if (CAN_USE_SPEECH) {
        const populateVoices = () => {
          speechVoices = window.speechSynthesis.getVoices() || [];
        };
        populateVoices();
        window.speechSynthesis.addEventListener("voiceschanged", populateVoices);
      }

      // --- NEW: PROGRESS MANAGER (Handles LocalStorage) ---
      class ProgressManager {
        constructor() {
          this.storageKey = "polyglot_mastery";
          this.metaKey = "__meta";
          this.data = this.load();
          this.masteryThreshold = 4; // Word is "Learned" after 4 consecutive correct answers
          this.ensureMeta();
        }

        load() {
          const stored = localStorage.getItem(this.storageKey);
          try {
            return stored ? JSON.parse(stored) : {};
          } catch (err) {
            console.warn("Progress data corrupted, resetting.", err);
            localStorage.removeItem(this.storageKey);
            return {};
          }
        }

        save() {
          localStorage.setItem(this.storageKey, JSON.stringify(this.data));
        }

        ensureMeta() {
          let changed = false;
          if (!this.data[this.metaKey]) {
            this.data[this.metaKey] = {};
            changed = true;
          }
          const meta = this.data[this.metaKey];
          if (typeof meta.xp !== "number") {
            meta.xp = 0;
            changed = true;
          }
          if (typeof meta.streak !== "number") {
            meta.streak = 0;
            changed = true;
          }
          if (!meta.lastPlayed) {
            meta.lastPlayed = null;
            changed = true;
          }
          if (changed) this.save();
        }

        getMeta() {
          this.ensureMeta();
          return this.data[this.metaKey];
        }

        getTodayKey() {
          return new Date().toISOString().split("T")[0];
        }

        getStrength(id) {
          if (id === this.metaKey) return 0;
          return this.data[id] || 0;
        }

        update(id, isCorrect) {
          if (id === this.metaKey) return 0;
          if (!this.data[id]) this.data[id] = 0;

          if (isCorrect) {
            this.data[id]++;
          } else {
            // Punishment: If you get it wrong, strength resets to 0 (Leitner system)
            this.data[id] = 0;
          }
          this.save();
          return this.data[id];
        }

        isMastered(id) {
          return (this.data[id] || 0) >= this.masteryThreshold;
        }

        resetData() {
          if (confirm("Reset all learning progress?")) {
            localStorage.removeItem(this.storageKey);
            location.reload();
          }
        }

        addXP(amount = 0) {
          const meta = this.getMeta();
          meta.xp = Math.max(0, (meta.xp || 0) + amount);
          this.save();
          return meta.xp;
        }

        getXP() {
          return this.getMeta().xp || 0;
        }

        xpToNext(level) {
          // Slightly increasing requirement so later levels feel harder.
          return Math.round(100 * Math.pow(1.2, level - 1));
        }

        getLevelData() {
          let xp = this.getXP();
          let level = 1;
          let xpForNext = this.xpToNext(level);

          while (xp >= xpForNext) {
            xp -= xpForNext;
            level++;
            xpForNext = this.xpToNext(level);
          }

          const progress = xpForNext === 0 ? 1 : xp / xpForNext;

          return {
            level,
            xpIntoLevel: xp,
            xpForNext,
            progress,
            totalXP: this.getXP(),
          };
        }

        recordDailyPlay() {
          const meta = this.getMeta();
          const today = this.getTodayKey();

          if (meta.lastPlayed === today) {
            return meta.streak || 0;
          }

          let newStreak = 1;

          if (meta.lastPlayed) {
            const prev = new Date(meta.lastPlayed);
            const now = new Date(today);
            const diffDays = Math.floor((now - prev) / (1000 * 60 * 60 * 24));

            if (diffDays === 1) {
              newStreak = (meta.streak || 0) + 1;
            } else {
              newStreak = 1;
            }
          }

          meta.streak = newStreak;
          meta.lastPlayed = today;
          this.save();
          return newStreak;
        }

        getStreak() {
          return this.getMeta().streak || 0;
        }
      }

      const progressManager = new ProgressManager();

      // --- DATA FETCHER ---
      class DataFetcher {
        static async loadGoogleSheet(url) {
          try {
            const response = await fetch(url);
            const text = await response.text();
            return this.csvToJson(text);
          } catch (error) {
            alert("Error loading data! Check your internet or CSV link.");
            console.error(error);
            return [];
          }
        }

        static csvToJson(csv) {
          const lines = csv.trim().split("\n");
          const headers = lines[0].split(",").map((h) => h.trim());
          const result = [];
          for (let i = 1; i < lines.length; i++) {
            const obj = {};
            const currentline = lines[i].split(",").map((c) => c.trim());
            if (currentline.length < headers.length) continue;
            headers.forEach((header, index) => (obj[header] = currentline[index]));
            if (obj.id && obj.en) result.push(obj);
          }
          return result;
        }
      }

      // --- GAME ENGINE ---
      class MatchGame {
        constructor() {
          this.fullData = [];
          this.deck = [];
          this.score = 0;
          this.selectedLeft = null;
          this.selectedRight = null;
          this.activePairs = 5;

          this.domLeft = document.querySelectorAll("#col-left .card-slot");
          this.domRight = document.querySelectorAll("#col-right .card-slot");
          this.scoreEl = document.getElementById("score");
          this.progressFill = document.getElementById("progress-fill");
          this.levelValueEl = document.getElementById("level-value");
          this.levelLabelEl = document.getElementById("level-label");
          this.levelXpEl = document.getElementById("xp-label");
          this.levelProgressFill = document.getElementById("level-progress-fill");
          this.streakValueEl = document.getElementById("streak-value");

          this.init();
        }

        async init() {
          this.fullData = await DataFetcher.loadGoogleSheet(SHEET_URL);
          if (this.fullData.length === 0) return;

          document.getElementById("loading-overlay").style.display = "none";
          document.getElementById("game-board").style.display = "grid";

          this.restart();
        }

        restart() {
          this.score = 0;
          this.updateUI();
          this.buildDeck();

          this.domLeft.forEach((slot) => (slot.innerHTML = ""));
          this.domRight.forEach((slot) => (slot.innerHTML = ""));

          // Fill initial board
          const starterSet = [];
          for (let i = 0; i < this.activePairs; i++) {
            if (this.deck.length > 0) starterSet.push(this.deck.pop());
          }

          const lefts = [...starterSet];
          const rights = [...starterSet].sort(() => 0.5 - Math.random());

          for (let i = 0; i < lefts.length; i++) {
            this.renderCard(this.domLeft[i], lefts[i], "left");
            this.renderCard(this.domRight[i], rights[i], "right");
          }
        }

        // --- NEW: INTELLIGENT DECK BUILDER ---
        buildDeck() {
          // 1. Separate words into "Mastered" and "Learning/New"
          const learning = [];
          const mastered = [];

          this.fullData.forEach((word) => {
            if (progressManager.isMastered(word.id)) {
              mastered.push(word);
            } else {
              learning.push(word);
            }
          });

          // 2. Shuffle both piles
          learning.sort(() => 0.5 - Math.random());
          mastered.sort(() => 0.5 - Math.random());

          // 3. Construct Deck Logic
          // If we have plenty of new/learning words, use those.
          // If we are running low (< 10), mix in mastered words for review.
          if (learning.length > 10) {
            this.deck = learning;
          } else {
            // Mix: 70% learning, 30% mastered
            this.deck = [...learning, ...mastered.slice(0, 10)];
            this.deck.sort(() => 0.5 - Math.random()); // Shuffle final mix
          }

          console.log(`Deck built: ${learning.length} new/weak words, ${mastered.length} mastered words hidden.`);
        }

        renderCard(slot, wordObj, side) {
          if (!wordObj) return;

          const lang =
            side === "left" ? document.getElementById("lang-left").value : document.getElementById("lang-right").value;
          const displayText = wordObj[lang] || wordObj.en || "";

          const card = document.createElement("div");
          card.className = "card entry";
          card.dataset.id = wordObj.id;
          card.dataset.side = side;

          const label = document.createElement("span");
          label.className = "card-label";
          label.innerText = displayText;
          card.appendChild(label);

          const speakBtn = document.createElement("button");
          speakBtn.type = "button";
          speakBtn.className = "speak-btn";
          speakBtn.innerHTML =
            '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5.5 8.5 9H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h3.5L12 18.5V5.5Zm4.7-.2a1 1 0 0 0-.9 1.8 5 5 0 0 1 0 9 1 1 0 0 0 .9 1.8 7 7 0 0 0 0-12.6Zm-2 2.6a1 1 0 0 0-.9 1.8 2 2 0 0 1 0 3.6 1 1 0 0 0 .9 1.8 4 4 0 0 0 0-7.2Z"/></svg>';
          speakBtn.setAttribute("aria-label", "Play pronunciation");
          speakBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            speakText(displayText, lang);
          });
          card.appendChild(speakBtn);

          card.addEventListener("click", () => this.handleCardClick(card));
          slot.appendChild(card);

          setTimeout(() => card.classList.remove("entry"), 300);
        }

        handleCardClick(card) {
          if (card.classList.contains("correct")) return;

          if (card.dataset.side === "left") {
            if (this.selectedLeft) this.selectedLeft.classList.remove("selected");
            this.selectedLeft = card;
          } else {
            if (this.selectedRight) this.selectedRight.classList.remove("selected");
            this.selectedRight = card;
          }
          card.classList.add("selected");

          if (this.selectedLeft && this.selectedRight) {
            this.checkMatch();
          }
        }

        checkMatch() {
          const id1 = this.selectedLeft.dataset.id;
          const id2 = this.selectedRight.dataset.id;

          if (id1 === id2) {
            this.handleCorrect(id1);
          } else {
            this.handleWrong(id1, id2);
          }
        }

        handleCorrect(id) {
          // Update Brain
          progressManager.update(id, true);

          const l = this.selectedLeft;
          const r = this.selectedRight;
          const slotL = l.parentElement;
          const slotR = r.parentElement;

          l.classList.add("correct");
          r.classList.add("correct");
          l.classList.remove("selected");
          r.classList.remove("selected");

          this.selectedLeft = null;
          this.selectedRight = null;
          this.score += 1;
          progressManager.addXP(XP_PER_MATCH);
          progressManager.recordDailyPlay();
          this.updateUI();

          setTimeout(() => {
            slotL.innerHTML = "";
            slotR.innerHTML = "";
            this.refillSlot(slotL, slotR, l.dataset.id);
          }, 200);
        }

        handleWrong(id1, id2) {
          // Update Brain (Penalty)
          progressManager.update(id1, false);
          progressManager.update(id2, false);

          const l = this.selectedLeft;
          const r = this.selectedRight;

          l.classList.add("wrong");
          r.classList.add("wrong");

          setTimeout(() => {
            l.classList.remove("wrong", "selected");
            r.classList.remove("wrong", "selected");
          }, 500);

          this.selectedLeft = null;
          this.selectedRight = null;
        }

        refillSlot(slotL, slotR, lastMatchedId) {
          // Get new word
          let newWord;

          if (this.deck.length > 0) {
            newWord = this.deck.pop();
          } else {
            // ENDLESS MODE FALLBACK
            // If the deck is empty (all words used in this session),
            // we recycle the word that was just matched so play continues.
            // Or we fetch a random word from fullData to keep it spicy.
            newWord = this.fullData.find((w) => w.id === lastMatchedId);
          }

          this.renderCard(slotL, newWord, "left");
          this.renderCard(slotR, newWord, "right");
        }

        updateUI() {
          this.scoreEl.innerText = this.score;
          // Visual progress bar just for the current "Session"
          const pct = ((this.score % 20) / 20) * 100;
          this.progressFill.style.width = pct + "%";

          const { level, xpIntoLevel, xpForNext, progress } = progressManager.getLevelData();
          if (this.levelValueEl) this.levelValueEl.innerText = level;
          if (this.levelLabelEl) this.levelLabelEl.innerText = `Level ${level}`;
          if (this.levelXpEl) this.levelXpEl.innerText = `${xpIntoLevel} / ${xpForNext} XP`;
          if (this.levelProgressFill) this.levelProgressFill.style.width = Math.min(progress * 100, 100) + "%";
          const streak = progressManager.getStreak();
          if (this.streakValueEl) this.streakValueEl.innerText = streak;
        }
      }

      const game = new MatchGame();

      function getVoiceFor(langCode) {
        if (!CAN_USE_SPEECH) return null;
        if (!speechVoices.length) {
          speechVoices = window.speechSynthesis.getVoices() || [];
        }
        if (!speechVoices.length) return null;

        const targetLocale = (LANGUAGE_LOCALES[langCode] || langCode || "en-US").toLowerCase();
        const base = targetLocale.split("-")[0];

        return (
          speechVoices.find((voice) => voice.lang && voice.lang.toLowerCase() === targetLocale) ||
          speechVoices.find((voice) => voice.lang && voice.lang.toLowerCase().startsWith(base))
        );
      }

      function speakText(text, langCode) {
        if (!text) return;
        if (!CAN_USE_SPEECH) {
          if (!speechSupportWarned) {
            alert("Text-to-speech is not supported in this browser.");
            speechSupportWarned = true;
          }
          return;
        }

        const locale = LANGUAGE_LOCALES[langCode] || langCode || "en-US";
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = locale;
        utterance.rate = 0.95;

        const preferredVoice = getVoiceFor(langCode);
        if (preferredVoice) {
          utterance.voice = preferredVoice;
        }

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      }

      window.speakText = speakText;

      function shareLevel() {
        const { level, xpIntoLevel, xpForNext, totalXP } = progressManager.getLevelData();
        const streak = progressManager.getStreak();
        const streakText = streak > 0 ? `ðŸ”¥ ${streak}-day streak!` : "No streak yetâ€”want to race me?";
        const shareText = `I'm Level ${level} in Match-Up (${xpIntoLevel}/${xpForNext} XP to next). Total XP: ${totalXP}. ${streakText}`;

        if (navigator.share) {
          navigator
            .share({
              title: "Match-Up Level",
              text: shareText,
              url: window.location.href,
            })
            .catch(() => {
              // Ignore if user cancels share sheet
            });
          return;
        }

        if (navigator.clipboard) {
          navigator.clipboard
            .writeText(shareText)
            .then(() => alert("Level copied! Send it to your partner."))
            .catch(() => alert(shareText));
          return;
        }

        alert(shareText);
      }
    </script>
  </body>
</html>
